---
title: 'Reference building for clustifyR'
date: '`r Sys.Date()`'
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
    vignette: >
      %\VignetteIndexEntry{clustifyR-reference}
      %\VignetteEngine{knitr::rmarkdown}
      %\VignetteEncoding{UTF-8}
---

```{r knitr_opts, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center"
)
```

## Building reference matrix from single cell expression matrix

In its simplest form, a reference matrix is built by averaging expression of a single cell RNA-seq expression matrix by cluster. Both log transformed or raw count matrices are supported.

```{r average, warning = F, message = F}
library(clustifyR)
new_ref_matrix <- average_clusters(pbmc4k_matrix, 
                                   cluster_info = pbmc4k_meta$cluster,
                                   log_scale = T)

head(new_ref_matrix)
```

## Building reference matrix from `seurat` object

For further convenience, a shortcut function for generating reference matrix from  `seurat` object is used here.

```{r seruat, warning=F, message=F}
new_ref_matrix <- use_seurat_comp(s_small,
                                  cluster_col = "res.1",
                                  var.genes_only = FALSE)

head(new_ref_matrix)
```

## Building reference matrix from Recount2

Bulk RNA-Seq data can be obtained from any input source; in this example we will obtain a dataset from the [recount2](https://jhubiostatistics.shinyapps.io/recount/) database. This database provides > 2000 human RNA-Seq experiments that have been processed using a consistent pipeline. We have written a wrapper function to download a count matrix from `recount2`, given an SRA ID. 

```{r recount, warning=F, message=F, eval = F}
library(dplyr)
library(purrr)
library(tidyr)
library(stringr)
library(recount)

dl_recount <- function(sra_id){
  if (!file.exists(file.path(sra_id, "rse_gene.Rdata"))) {
    download_study(sra_id)
  }
  load(file.path(sra_id, "rse_gene.Rdata"))
  # no longer need to downloaded data
  unlink(sra_id, recursive = TRUE)
  rse <- scale_counts(rse_gene)
  read_counts <- assay(rse, "counts")
  gene_ids <- rownames(read_counts)
  # get gene symbols, which are stored in rowData
  id2symbol <- data_frame(ids = rowData(rse_gene)$gene_id,
             symbols = rowData(rse_gene)$symbol@listData) %>%
    mutate(symbols = map_chr(symbols, ~.x[1]))

  # clean up metadata into a dataframe
  print("cleaning up meta")
  mdata <- colData(rse)
  mdata_cols <- lapply(mdata$characteristics,
      function(x){str_match(x, "^([^:]+):")[, 2]}) %>%
        unique() %>%
        unlist()

  mdata <- data_frame(run =  mdata$run,
                      all_data = as.list(mdata$characteristics)) %>%
    mutate(out = purrr::map_chr(all_data,
                                ~str_c(.x, collapse = "::"))) %>%
  tidyr::separate(out,
                  sep = "::",
                  into = mdata_cols) %>%
    select(-all_data) %>%
    mutate_at(.vars = vars(-matches("run")),
              .funs = function(x) str_match(x, ": (.+)")[, 2])

  # convert ids to symbols
  row_ids_to_symbols <- left_join(data_frame(ids = gene_ids),
            id2symbol, by = "ids")

  if(length(gene_ids) != nrow(row_ids_to_symbols)) {
    warning("gene id mapping to symbols produce more or less ids")
  }

  row_ids_to_symbols <- filter(row_ids_to_symbols, !is.na(symbols))
  out_df <- read_counts %>%
    as.data.frame() %>%
    tibble::rownames_to_column("gene_id") %>%
    left_join(., row_ids_to_symbols,
              by = c("gene_id" = "ids")) %>%
    dplyr::select(-gene_id) %>%
    dplyr::select(symbols, everything()) %>%
    filter(!is.na(symbols))

  out_matrix <- tidyr::gather(out_df, library, expr, -symbols) %>%
    group_by(symbols, library) %>%
    summarize(expr = sum(expr)) %>%
    tidyr::spread(library, expr) %>%
    as.data.frame() %>%
    tibble::column_to_rownames("symbols") %>%
    as.matrix()

  list(read_counts = out_matrix,
       meta_data = mdata)
}

gtex_data <- dl_recount("SRP012682")

gtex_data$read_counts[1:5, 1:5]
gtex_data$meta_data[1:5, ]
```

## Building reference gene list

`clustify_lists` and `clustify_nudge` uses dataframe or matrix of candidate genes for classification. Example formatting are shown below.

```{r genelist, warning = F, message = F}
head(pbmc4k_markers)

head(cbmc_m)
```

## Prebuilt references, in clustifyR

A few reference datasets are built into clustifyR for vignettes and testing:
`pbmc_bulk_matrix`,
`cbmc_ref`,
`pbmc4k_markers`,
`cbmc_m`

## Prebuilt references, in clustifyrdata

More reference data (including tabula muris) can be found at https://github.com/rnabioco/clustifyrdata.
