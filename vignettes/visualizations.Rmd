---
title: 'Visualization of clustifyr results'
date: '`r Sys.Date()`'
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
    vignette: >
      %\VignetteIndexEntry{clustifyR-viz}
      %\VignetteEngine{knitr::rmarkdown}
      %\VignetteEncoding{UTF-8}
---

```{r knitr_opts, echo = FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center"
)
```

The `clustifyr()` function outputs a matrix of correlation coefficients and `clustify_lists()` and `clustify_nudge()` output positive scores. `clustifyr` provides built-in functions to help visualize these results.

## Plotting correlation coefficients

```{r "Run clustifyr", fig.height = 8, fig.width = 10}
library(clustifyR)

# Matrix of normalized single-cell RNA-seq counts
full_pbmc4k_matrix <- pbmc4k_matrix

# meta.data table containing cluster assignments for each cell 
full_pbmc4k_meta <- pbmc4k_meta

# Run clustifyr()
res <- clustify(
  input = full_pbmc4k_matrix,     # matrix of normalized single-cell RNA-seq counts
  metadata = full_pbmc4k_meta,    # meta.data table containing cluster assignments for each cell
  ref_mat = cbmc_ref,             # reference matrix containing buld RNA-seq data for each cell type
  query_genes = pbmc4k_vargenes,  # list of highly varible genes identified with Seurat
  cluster_col = "cluster"         # name of column in meta.data containing cell clusters
)

```

```{r "Overlay corr coefficients on UMAP", fig.height = 5.5, fig.width = 12}
# plot_cor generates a plot for each reference cluster
plot_cor(
  cor_matrix = res,                   # matrix of correlation coefficients from clustifyr()
  metadata = full_pbmc4k_meta,        # meta.data table containing cluster assignments for each cell
  data_to_plot = colnames(res)[1:2],  # name of cell type(s) to plot correlation coefficients
  cluster_col = "cluster"             # name of column in meta.data containing cell clusters
)
```

```{r "Label clusters with cell types", fig.height = 8, fig.width = 10}
# plot_best_call to view called identities in one plot
plot_best_call(
  cor_matrix = res,             # matrix of correlation coefficients from clustifyr()
  metadata = full_pbmc4k_meta,  # meta.data table containing UMAP or tSNE data
  do_label = TRUE,              # should the feature label be shown on each cluster?
  do_legend = FALSE             # should the legend be shown?
)
```

```{r}

plot_tsne(
  cor_matrix = res,                   # matrix of correlation coefficients from clustifyr()
  metadata = full_pbmc4k_meta,        # meta.data table containing cluster assignments for each cell
  data_to_plot = colnames(res)[1:2],  # name of cell type(s) to plot correlation coefficients
  cluster_col = "cluster"             # name of column in meta.data containing cell clusters
)


plot_tsne
plot_gene
plot_call
plot_cols

```



## Heatmap
```{r "Correlation heatmap"}
res <- clustify(
  input = full_pbmc4k_matrix,
  metadata = full_pbmc4k_meta,
  cluster_col = "cluster",
  ref_mat = cbmc_ref
)

plot_cor_heatmap(res)

res2 <- clustify_lists(
  input = full_pbmc4k_matrix,
  cluster_info = full_pbmc4k_meta,
  cluster_col = "cluster",
  marker = pbmc4k_markers,
  marker_inmatrix = F
)

plot_cor_heatmap(res2)
```

## GSEA top hits per cluster
Using the gsea method implemented, we can also convert reactome/GO/pathway gene lists into forms that can be scored and plotted.
```{r "GSEA top hits"}
# gene lists can be converted from gmt files (Broad)
list_reactome <- gmt_to_list(here("c2.cp.reactome.v6.2.symbols.gmt"))

full_pbmc4k_avg <- average_clusters(
  full_pbmc4k_matrix, 
  full_pbmc4k_meta, 
  cluster_col = "classified"
)

res <- plot_pathway_gsea(
  full_pbmc4k_avg[,1:2], 
  list_reactome, 
  topn = 3)

# returns dataframe of gsea analysis
res[[1]][1:2,1:2]
# and plot
res[[2]]
```

## other attributes in the metadata
Visualization of other attributes shared in the metadata between ref and query by `plot_cols`, such as nGene, nUMI, mt_percentage, as another way of identity confirmation after `clustify`. Certain cell types have distinct patterns, more genes detected, for example.



```{r "Overclustering test", eval = F, include = F}
# intentionally overcluster and clustify to assess idents
# in this case, overclustered local averages agree with cluster clustify results
overcluster_test(
  expr = full_pbmc4k_matrix,
  metadata = full_pbmc4k_meta, 
  ref_mat = cbmc_ref,
  cluster_col = "cluster",
  n = 5
)
```

```{r eval = F, include = F}
# `clustify` against reference combinations also informs clustering
# in this case, several clusters seems to be a mixture with neighboring idents
comb_ref <- make_comb_ref(cbmc_ref)
res2 <- clustify(
  input = full_pbmc4k_matrix,
  metadata = full_pbmc4k_meta,
  cluster_col = "cluster",
  ref_mat = comb_ref,
  query_genes = pbmc4k_vargenes
)
plot_best_call(
  res2,
  full_pbmc4k_meta,
  do_label = T
)
```



